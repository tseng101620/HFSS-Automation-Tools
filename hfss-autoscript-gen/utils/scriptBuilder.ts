export interface SweepVariable {
  id: string;
  name: string;
  start: number;
  stop: number;
  step: number;
  units: string;
}

export interface ScriptConfig {
  targetPlatform: 'windows' | 'linux';
  solutionName: string; 
  sweepName: string;    
  parametricSetupName: string;
  variables: SweepVariable[];
  exportPath: string;
  filenamePrefix: string;
  includeVarInName: boolean;
  numPorts: number;
  debugMode: boolean;
  simulateIndividually: boolean;
  smartExport: boolean;
}

export const generateHfssScript = (config: ScriptConfig): string => {
  const {
    targetPlatform,
    solutionName,
    sweepName,
    parametricSetupName,
    variables,
    exportPath,
    filenamePrefix,
    includeVarInName,
    numPorts,
    debugMode,
    simulateIndividually,
    smartExport,
  } = config;

  // Format variables for Python list
  const pyVariables = variables.map(v => 
    `    {"name": "${v.name}", "start": ${v.start}, "stop": ${v.stop}, "step": ${v.step}, "units": "${v.units}"}`
  ).join(',\n');

  const scriptContent = `# HFSS Automation Script
# Generated by HFSS AutoScript Gen
# Target Platform: ${targetPlatform === 'linux' ? 'Linux (CentOS/RHEL)' : 'Windows'}
# -----------------------------------------------------------------------
import os
import time
import math
from System import Array, String, Double

# --- Configuration Section ---
parametric_setup_name = "${parametricSetupName}"
solution_setup_name = "${solutionName} : ${sweepName}"
base_setup_name = "${solutionName}"
export_folder = r"${exportPath}"
filename_prefix = "${filenamePrefix}"
include_var_in_filename = ${includeVarInName ? 'True' : 'False'}
file_extension = ".s${numPorts}p" 
debug_mode = ${debugMode ? 'True' : 'False'}
simulate_individually = ${simulateIndividually ? 'True' : 'False'}
smart_export = ${smartExport ? 'True' : 'False'}

# List of sweep variables
# In Smart Export mode, these names are used to filter the output filename.
sweep_variables = [
${pyVariables}
]

# -----------------------------------------------------------------------
# Initialize HFSS
try:
    oDesktop
except NameError:
    import ScriptEnv
    ScriptEnv.Initialize("Ansoft.ElectronicsDesktop")
    oDesktop = ScriptEnv.GetDesktop()

try:
    oDesktop.RestoreWindow()
except:
    pass

oProject = oDesktop.GetActiveProject()
oDesign = None
oSolutionModule = None
oOptimetricsModule = None

if oProject:
    oDesign = oProject.GetActiveDesign()
    if oDesign:
        oSolutionModule = oDesign.GetModule("Solutions")
        try:
            oOptimetricsModule = oDesign.GetModule("Optimetrics")
        except:
            oOptimetricsModule = None

# -----------------------------------------------------------------------
# Helper Functions

def log(msg):
    prefix = "[Script] "
    full_msg = prefix + str(msg)
    print(full_msg)
    try:
        p_name = oProject.GetName() if oProject else ""
        d_name = oDesign.GetName() if oDesign else ""
        oDesktop.AddMessage(p_name, d_name, 0, str(msg))
    except:
        pass

def float_range(start, stop, step):
    if step <= 0:
        yield start
        return
    current = start
    epsilon = step / 1000.0
    while current <= stop + epsilon:
        yield current
        current += step

def format_value(val):
    val_float = float(val)
    s = "{:.12g}".format(val_float)
    return s

def get_combinations(vars_list, current_combo=[]):
    if not vars_list:
        yield current_combo
        return

    var_data = vars_list[0]
    name = var_data["name"]
    start = var_data["start"]
    stop = var_data["stop"]
    step = var_data["step"]
    units = var_data["units"]

    for val in float_range(start, stop, step):
        val_str = format_value(val)
        if units:
            val_str += units
        new_combo = current_combo + [(name, val_str)]
        for res in get_combinations(vars_list[1:], new_combo):
            yield res

def set_variable(var_name, var_value):
    """Sets a Local Variable in the design using ChangeProperty."""
    try:
        oDesign.ChangeProperty(
            [
                "NAME:AllTabs",
                [
                    "NAME:LocalVariableTab",
                    [
                        "NAME:PropServers", 
                        "LocalVariables"
                    ],
                    [
                        "NAME:ChangedProps",
                        [
                            "NAME:" + var_name,
                            "Value:=", var_value
                        ]
                    ]
                ]
            ]
        )
        return True
    except Exception as e:
        log("Error setting variable " + var_name + ": " + str(e))
        return False

def get_filename_suffix_smart(full_variation_string, target_vars):
    """
    Robust non-regex parser to extract variables.
    Returns: (suffix_string, list_of_found_keys)
    """
    parts = []
    # HFSS Variation String Format: "Var1='Val1' Var2='Val2'"
    # Split by space is mostly safe for values like '1mm'
    tokens = full_variation_string.split(' ')
    
    target_names = [t['name'] for t in target_vars]
    found_keys = []
    
    for token in tokens:
        if "=" not in token:
            continue
        
        # Split strictly on first = to handle Name='Value'
        eq_idx = token.find('=')
        if eq_idx == -1: continue

        key = token[:eq_idx]
        val = token[eq_idx+1:]
        
        # Clean quotes: '1mm' -> 1mm
        val = val.replace("'", "").replace('"', "")
        
        found_keys.append(key)
        
        if key in target_names:
             # Sanitize value for filename
             clean_val = val.replace('.', 'd')
             parts.append("{}_{}".format(key, clean_val))

    if len(parts) == 0:
        return None, found_keys
        
    return "_".join(parts), found_keys

def calculate_expected_variations(vars_list):
    total = 1
    for v in vars_list:
        if v["step"] <= 0: continue
        # Add epsilon to handle floating point errors
        count = int(math.floor((v["stop"] - v["start"] + (v["step"]/1000.0)) / v["step"])) + 1
        total *= count
    return total

# -----------------------------------------------------------------------
# Main Execution

def main():
    if oProject is None or oDesign is None:
        print("Error: HFSS Project/Design not open.") 
        return

    log("Script Started. Mode: " + ("DEBUG" if debug_mode else "NORMAL"))
    
    # Determine Mode
    if smart_export:
        log("Mode: SMART EXPORT (Auto-Detect Variations)")
    elif simulate_individually:
        log("Mode: MANUAL LOOP (Robust)")
    else:
        log("Mode: PARAMETRIC RESULT EXTRACT")

    # Ensure export folder exists
    if not os.path.exists(export_folder):
        try:
            os.makedirs(export_folder)
        except Exception as e:
            log("CRITICAL: Cannot create export folder: " + str(e))
            return

    # Prepare Arrays for Complex Signatures
    emptyStrArray = Array[String]([])
    emptyDblArray = Array[Double]([])
    
    # -----------------------------------------------------------
    # PATH A: SMART EXPORT (Auto-Detect from Solution)
    # -----------------------------------------------------------
    if smart_export:
        # 1. Run Analysis FIRST (to ensure results exist)
        log("--- Step 1: Running Analysis ---")
        analysis_performed = False
        
        # Try running Parametric Setup first
        if oOptimetricsModule and parametric_setup_name:
            log("Attempting to solve Parametric Setup: " + parametric_setup_name)
            try:
                # Check if setup exists by trying to access it (lightweight check not available, so we try/catch)
                oOptimetricsModule.SolveSetup(parametric_setup_name)
                log("Parametric Analysis Completed.")
                analysis_performed = True
            except Exception as e:
                log("Parametric Setup failed or not found: " + str(e))
                log("Proceeding to check for existing results or fallback analysis.")

        # Fallback to standard Analyze if Parametric didn't run or wasn't configured
        if not analysis_performed:
            log("Attempting standard Analyze on: " + base_setup_name)
            try:
                oDesign.Analyze(base_setup_name)
                log("Standard Analysis Completed.")
            except Exception as e:
                 log("Standard Analysis failed: " + str(e))
        
        # 2. Get Available Variations from HFSS directly
        log("--- Step 2: Detecting Variations ---")
        try:
            variations = oSolutionModule.GetAvailableVariations(solution_setup_name)
            
            if variations is None or len(variations) == 0:
                log("CRITICAL: No variations found for setup: " + solution_setup_name)
                log("  Ensure the simulation completed successfully.")
                return

            found_count = len(variations)
            expected_count = calculate_expected_variations(sweep_variables)
            
            log("Found " + str(found_count) + " variations in HFSS.")
            
            if expected_count > 0 and found_count != expected_count:
                log("WARNING: Expected " + str(expected_count) + " variations based on your variables, but found " + str(found_count) + ".")
                log("  This usually means some variations failed to solve.")

            count = 0
            for i, var_key in enumerate(variations):
                
                # 2.5 Filter Stale Results (Range Check)
                is_valid_range = True
                for sv in sweep_variables:
                     # Robustly find var='val' in string
                     # Format is "Name='Val' Name2='Val2'"
                     tokens = var_key.split(' ')
                     for token in tokens:
                         if "=" not in token: continue
                         eq_idx = token.find('=')
                         t_name = token[:eq_idx]
                         t_val = token[eq_idx+1:].replace("'", "").replace('"', "")
                         
                         if t_name == sv['name']:
                             # Parse float (handle units)
                             val_num = ""
                             for c in t_val:
                                 if c.isdigit() or c == '.' or c == '-' or c == '+' or c == 'e' or c == 'E':
                                     val_num += c
                                 else:
                                     break # Stop at unit
                             
                             try:
                                 f_val = float(val_num)
                                 # Check bounds with tolerance
                                 if f_val < (sv['start'] - 1e-9) or f_val > (sv['stop'] + 1e-9):
                                     is_valid_range = False
                                     if debug_mode:
                                         log("Skipping Stale Result (Out of Range): {}={} (Expected [{}, {}])".format(t_name, t_val, sv['start'], sv['stop']))
                             except:
                                 pass
                         if not is_valid_range: break
                     if not is_valid_range: break
                
                if not is_valid_range:
                    continue

                # 3. Construct Filename
                fname = filename_prefix + file_extension
                
                if include_var_in_filename:
                    # Filter variables to keep filename short
                    safe_suffix, found_keys = get_filename_suffix_smart(var_key, sweep_variables)
                    
                    if safe_suffix:
                         fname = "{}_{}{}".format(filename_prefix, safe_suffix, file_extension)
                    else:
                         # Fallback diagnostics
                         if i == 0: # Only log once
                             log("WARNING: No matching variables found for filename!")
                             log("  Your Configured List: " + str([t['name'] for t in sweep_variables]))
                             log("  Variables Found in HFSS: " + str(found_keys))
                             log("  Action: Add the exact HFSS variable names to your configuration to fix the filenames.")
                             
                         fname = "{}_Run_{}{}".format(filename_prefix, i+1, file_extension)
                
                full_path = os.path.join(export_folder, fname)
                
                if debug_mode:
                    log("Exporting to: " + fname)

                # 4. Export
                success = False
                
                # Strategy 3: Reference Code Signature (Strict)
                try:
                    oSolutionModule.ExportNetworkData(
                        var_key, 
                        Array[String]([solution_setup_name]), 
                        3, 
                        full_path, 
                        Array[String](["All"]), 
                        True, 
                        50.0, 
                        "S", 
                        -1, 
                        0, 
                        15, 
                        True, 
                        False, 
                        False
                    )
                    success = True
                except Exception as e:
                    if "Solution data is not available" in str(e):
                         log("SKIP: Variation listed in DB but has no results (Invalid/Unsolved).")
                    elif debug_mode:
                         log("Strategy 3 failed: " + str(e))
                
                # Fallback: Strategy 1 (Simple)
                if not success:
                    try:
                        oSolutionModule.ExportNetworkData(solution_setup_name, full_path, 3, False, var_key)
                        success = True
                    except:
                        pass
                
                # 5. Verify File Creation
                if success:
                    if os.path.exists(full_path):
                        count += 1
                    else:
                        log("ERROR: Export command succeeded but file not found: " + fname)
                else:
                    if not "Solution data is not available" in str(e):
                        log("Failed to export variation.")

            log("Smart Export Finished. Successfully exported: " + str(count))
            
        except Exception as e:
            log("Smart Export Critical Error: " + str(e))
            
        return

    # -----------------------------------------------------------
    # PATH B: SIMULATE INDIVIDUALLY (Robust Manual Loop)
    # -----------------------------------------------------------
    if simulate_individually:
        count = 0
        log("Starting Manual Simulation Loop...")
        
        for combo in get_combinations(sweep_variables):
            # 1. Set Variables
            variation_log = []
            for item in combo:
                var_name = item[0]
                var_val = item[1]
                set_variable(var_name, var_val)
                variation_log.append(var_name + "=" + var_val)
            
            var_msg = ", ".join(variation_log)
            log("Configured Design: " + var_msg)

            # 2. Analyze
            try:
                oDesign.Analyze(base_setup_name)
            except Exception as e:
                log("Analysis Failed for " + var_msg)
                log("Error: " + str(e))
                continue # Skip export if solve failed

            # 3. Export (Nominal)
            # Construct filename
            safe_combo = [(c[0], c[1].replace('.', 'd')) for c in combo]
            if include_var_in_filename:
                var_suffix = "_".join(["{}_{}".format(i[0], i[1]) for i in safe_combo])
                fname = "{}_{}{}".format(filename_prefix, var_suffix, file_extension)
            else:
                var_suffix = "_".join(["{}".format(i[1]) for i in safe_combo])
                fname = "{}_{}{}".format(filename_prefix, var_suffix, file_extension)
            
            full_path = os.path.join(export_folder, fname)

            # Try Nominal Export Strategies
            success = False
            
            try:
                oSolutionModule.ExportNetworkData(solution_setup_name, full_path, 3, "")
                success = True
            except:
                pass
            
            if not success:
                try:
                    oSolutionModule.ExportNetworkData(
                        solution_setup_name, 
                        emptyStrArray, 
                        3, 
                        full_path, 
                        emptyDblArray, 
                        False, 
                        50.0, 
                        "S", 
                        -1, 
                        0, 
                        15
                    )
                    success = True
                except Exception as e:
                    log("Export failed: " + str(e))

            if success:
                if os.path.exists(full_path):
                    count += 1
                    log("Exported: " + fname)
                else:
                    log("Error: File not found after export: " + fname)
            
        log("Manual Loop Finished. Total: " + str(count))
        return

    # -----------------------------------------------------------
    # PATH C: PARAMETRIC EXTRACT (Legacy)
    # -----------------------------------------------------------
    # (Kept for compatibility, though Smart Export replaces it)
    log("Mode: LEGACY PARAMETRIC EXTRACT")
    
    # 1. Run Parametric Sweep
    log("Starting Parametric Analysis: " + parametric_setup_name)
    analysis_success = False
    
    if oOptimetricsModule:
        try:
            oOptimetricsModule.SolveSetup(parametric_setup_name)
            log("Optimetrics Analysis Finished.")
            analysis_success = True
        except Exception as e:
            log("Optimetrics solve warning: " + str(e))
    
    if not analysis_success:
        try:
            oDesign.Analyze(parametric_setup_name)
            log("Standard Analysis Finished.")
        except Exception as e:
            log("Analysis failed: " + str(e))

    log("Starting Export Loop to: " + export_folder)
    
    count = 0
    for combo in get_combinations(sweep_variables):
        variation_parts = ["{}='{}'".format(item[0], item[1]) for item in combo]
        variation_string = " ".join(variation_parts)
        
        safe_combo = [(c[0], c[1].replace('.', 'd')) for c in combo]

        if include_var_in_filename:
            var_suffix = "_".join(["{}_{}".format(i[0], i[1]) for i in safe_combo])
            fname = "{}_{}{}".format(filename_prefix, var_suffix, file_extension)
        else:
            var_suffix = "_".join(["{}".format(i[1]) for i in safe_combo])
            fname = "{}_{}{}".format(filename_prefix, var_suffix, file_extension)
            
        full_path = os.path.join(export_folder, fname)
        
        success = False
        last_error = ""

        if not success:
            try:
                oSolutionModule.ExportNetworkData(solution_setup_name, full_path, 3, False, variation_string)
                success = True
            except:
                pass 

        if not success:
            try:
                oSolutionModule.ExportNetworkData(solution_setup_name, full_path, 3, 0, variation_string)
                success = True
            except:
                pass
        
        if not success:
            try:
                oSolutionModule.ExportNetworkData(
                    "{} : {}".format(solution_setup_name, variation_string), 
                    emptyStrArray, 
                    3, 
                    full_path, 
                    emptyDblArray, 
                    False, 
                    50.0, 
                    "S", 
                    -1, 
                    0, 
                    15
                )
                success = True
            except Exception as e:
                last_error = str(e)

        if success:
             if os.path.exists(full_path):
                count += 1
        else:
            if debug_mode:
                log("FAILED Export: " + variation_string + " | " + last_error)

    log("Export finished. Total exported: " + str(count))

if __name__ == "__main__":
    main()`;

  return scriptContent;
};
